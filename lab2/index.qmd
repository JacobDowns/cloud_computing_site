---
title: "Lab 2 — Extend Lab 1 with Google Sign-In + Firestore Notes (and Rules)"
---

## Overview

::: {.callout-note collapse="false"}
## lab2.exe — What you are doing

In this lab, you will extend your Lab 1 app, into a simple notes app. The main features you'll implement:

- Allow users to sign in with Google
- Allow users to create and delete personal notes
- Store notes permanently in Firestore

This lab is Spark (free tier) friendly. You won't need to enable the paid Blaze plan. As before, you'll deploy a real, live app at the end. 
:::

## Starting point

::: {.callout-important collapse="false"}
## baseline.exe — Confirm Lab 1 works first

Open your **Lab 1 repository** (the one you already deployed to Firebase Hosting).

Before you begin Lab 2, confirm:

```bash
npm install
npm run dev
```

and that your deploy still works:

```bash
npm run build
firebase deploy
```

If your Lab 1 deploy is broken, fix it **before** continuing.
:::

## Prerequisites

::: {.callout-warning collapse="false"}
## prereq.dll — You need these tools

After lab 1, you should already have these prerequisites. Make sure you have:

- **Node.js (LTS)** (includes npm): https://nodejs.org  
- Verify in a terminal:

```bash
node -v
npm -v
```

- **Git** installed
- A **GitHub** account
- A **Google** account (for Firebase + Google Sign-In)
- Firebase CLI installed:

```bash
npm install -g firebase-tools
firebase --version
```
:::

---

## Part A — Add Firebase services to your existing Lab 1 project

### Use the same Firebase project from Lab 1
You will use your existing Firebase project (the one tied to your Hosting deploy). That keeps everything in one place.

::: {.callout-tip collapse="false"}
## hint.txt — Find your project id
You probably only have one project in Firebase, but if not, in your repo, check `.firebaserc` for your project id. Example:

```json
{
  "projects": {
    "default": "my-project-id"
  }
}
```
:::

## Step 1 — Enable Google Sign-In (Authentication)

::: {.callout-important collapse="false"}
## auth.exe — Enable provider

* In the Firebse Console, with your project opened, go to **Build → Authentication → Sign-in method**
* In the section on additional providers, click on Google. 
* Check enable and use your gmail address as the support email. 
* This allows “Sign in with Google” in your app.
:::

## Step 2 — Create a Firestore database

::: {.callout-note collapse="false"}
## db.exe — Firestore setup

In the Firebse Console, with your project opened, go to **Build → Firestore Database → Create database**

- Use standard edition. 
- Pick any region
- Click on start in **test mode** (temporary!)

We will lock this down with rules later.
:::

## Step 3 — Register a Web App (to get config values)

::: {.callout-note collapse="false"}
## webapp.exe — Firebase config

Hosting-only apps don’t always need a web config, but Auth + Firestore require this.

- Go to Project settings → **General** → “Your apps” → **Web**
- **Note:** Project settings looks like a little gear. 
- Register an app name (e.g., `cloud-notes-web`) and copy the config values.
- You can leave the "Firebase Hosting" check box unchecked. 
- Note that this returns some information you'll need for the SDK later. I'd recommend copyting this into a temporary file on your PC now because you'll need this information in Step 6. However, you can also retrieve this later. 
:::

---

## Part B — Add Firebase SDK + env vars to your Lab 1 codebase

## Step 4 — Install the Firebase SDK

::: {.callout-note collapse="false"}
## install.exe

In your repo folder:

```bash
npm install firebase
```
:::

## Step 5 — Create `.env.local` (do not commit)

::: {.callout-warning collapse="false"}
## env.dll — Local config

Create a file named **`.env.local`** in the project root (same folder as `package.json`).

Fill it with your Firebase config values (no quotes):

```env
VITE_FIREBASE_API_KEY=PASTE_ME
VITE_FIREBASE_AUTH_DOMAIN=PASTE_ME
VITE_FIREBASE_PROJECT_ID=PASTE_ME
VITE_FIREBASE_APP_ID=PASTE_ME
```

Then ensure `.env.local` is in `.gitignore`:

```gitignore
.env.local
```

This file defines the information needed by the SDK. Basically it tells the app which Firebase project to talk to. 

**Restart** `npm run dev` after editing `.env.local`.
:::

---

## Part C — Paste the code (copy/paste)

::: {.callout-note collapse="false"}
## code.exe — Files to create/replace

Now you will paste code into these files (create them if needed):

- `src/firebase.ts`
- `src/auth.ts`
- `src/notes.ts`
- `src/App.tsx`

**Tip:** If you see TypeScript warnings about types, use `import type { ... }`.
:::

## Step 6 — `src/firebase.ts`



This file creates a single Firebase app instance from the config and exports ready-to-use handles for services. Import these handles (auth, db, etc.) from other modules instead of initializing Firebase multiple times. It answers the question “which Firebase project am I connected to?”

```ts
// src/firebase.ts
import { initializeApp } from "firebase/app";
import { getAuth } from "firebase/auth";
import { getFirestore } from "firebase/firestore";

const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID,
};

export const app = initializeApp(firebaseConfig);
export const auth = getAuth(app);
export const db = getFirestore(app);
```

## Step 7 — `src/auth.ts`

Small wrapper functions around the Firebase Auth SDK. Exports functions to sign in (Google popup), sign out, and subscribe to auth state changes. Keeps authentication logic separate from UI so `App.tsx` can remain focused on rendering and state.

```ts
// src/auth.ts
import {
  GoogleAuthProvider,
  onAuthStateChanged,
  signInWithPopup,
  signOut,
} from "firebase/auth";

import type { User } from "firebase/auth";
import { auth } from "./firebase";

const provider = new GoogleAuthProvider();

/** Sign in with Google (popup) */
export async function signInWithGooglePopup(): Promise<User> {
  const cred = await signInWithPopup(auth, provider);
  return cred.user;
}

/** Sign out current user */
export async function signOutUser(): Promise<void> {
  await signOut(auth);
}

/** Subscribe to auth state changes; returns unsubscribe function */
export function subscribeToAuthChanges(cb: (user: User | null) => void): () => void {
  return onAuthStateChanged(auth, cb);
}
```

## Step 8 — `src/notes.ts`

Encapsulates Firestore operations: adding notes, deleting notes, and creating realtime subscriptions. Provides both the per-user query (subscribeToNotes) and the demo/all-notes subscription (`subscribeToAllNotes`).

```ts
// src/notes.ts
import {
  addDoc,
  collection,
  deleteDoc,
  doc,
  onSnapshot,
  orderBy,
  query,
  serverTimestamp,
  where,
} from "firebase/firestore";

import type { User } from "firebase/auth";
import { db } from "./firebase";

export type Note = {
  id: string;
  text: string;
};

export async function addNote(user: User, text: string): Promise<void> {
  await addDoc(collection(db, "notes"), {
    uid: user.uid,
    text,
    createdAt: serverTimestamp(),
  });
}

export function subscribeToNotes(
  user: User,
  cb: (notes: Note[]) => void,
  onError?: (err: Error) => void
): () => void {
  const q = query(
    collection(db, "notes"),
    where("uid", "==", user.uid),
    orderBy("createdAt", "desc")
  );

  return onSnapshot(
    q,
    (snapshot) => {
      const notes: Note[] = snapshot.docs.map((d) => ({
        id: d.id,
        text: d.data().text as string,
      }));
      cb(notes);
    },
    (error) => {
      if (onError) onError(error as Error);
      else console.error("subscribeToNotes error:", error);
    }
  );
}

/** Demo helper (insecure): subscribe to ALL notes */
export function subscribeToAllNotes(
  cb: (notes: Note[]) => void,
  onError?: (err: Error) => void
): () => void {
  const q = query(collection(db, "notes"), orderBy("createdAt", "desc"));

  return onSnapshot(
    q,
    (snapshot) => {
      const notes: Note[] = snapshot.docs.map((d) => ({
        id: d.id,
        text: d.data().text as string,
      }));
      cb(notes);
    },
    (error) => {
      if (onError) onError(error as Error);
      else console.error("subscribeToAllNotes error:", error);
    }
  );
}

export async function deleteNote(noteId: string): Promise<void> {
  await deleteDoc(doc(db, "notes", noteId));
}
```

## Step 9 — `src/App.tsx`

The single React component that wires the app together: subscribes to auth state, switches between the “logged out” and “notes” views, calls notes.ts helpers, and surfaces status/error messages.

```ts
// src/App.tsx
import React, { useEffect, useState } from "react";
import type { User } from "firebase/auth";

import { signInWithGooglePopup, signOutUser, subscribeToAuthChanges } from "./auth";
import { addNote, deleteNote, subscribeToAllNotes, subscribeToNotes } from "./notes";

type Note = {
  id: string;
  text: string;
};

export default function App(): JSX.Element {
  const [user, setUser] = useState<User | null>(null);
  const [status, setStatus] = useState<string | null>(null);
  const [errorMsg, setErrorMsg] = useState<string | null>(null);

  const [notes, setNotes] = useState<Note[]>([]);
  const [newText, setNewText] = useState<string>("");

  // Demo toggle (insecure until rules are added)
  const [showAll, setShowAll] = useState(false);

  useEffect(() => {
    const unsub = subscribeToAuthChanges((u) => {
      setUser(u);
      if (!u) setNotes([]);
    });
    return () => unsub();
  }, []);

  useEffect(() => {
    setErrorMsg(null);

    if (!user && !showAll) {
      setNotes([]);
      return;
    }

    setStatus("Loading notes...");

    const onErr = (err: Error) => {
      console.error(err);
      setStatus(null);
      setErrorMsg(err?.message ?? "Firestore listener error");
    };

    const unsub = showAll
      ? subscribeToAllNotes((f) => { setNotes(f); setStatus(null); }, onErr)
      : subscribeToNotes(user as User, (f) => { setNotes(f); setStatus(null); }, onErr);

    return () => unsub();
  }, [user, showAll]);

  async function handleSignIn() {
    setStatus("Signing in...");
    try {
      await signInWithGooglePopup();
      setStatus(null);
    } catch (err: any) {
      setStatus(null);
      setErrorMsg(err?.message ?? "Sign-in failed");
    }
  }

  async function handleSignOut() {
    setStatus("Signing out...");
    try {
      await signOutUser();
      setStatus(null);
    } catch (err: any) {
      setStatus(null);
      setErrorMsg(err?.message ?? "Sign-out failed");
    }
  }

  async function handleAddNote() {
    if (!user) {
      setErrorMsg("You must be signed in to add a note.");
      return;
    }
    const text = newText.trim();
    if (!text) return;

    setStatus("Saving...");
    setErrorMsg(null);

    try {
      await addNote(user, text);
      setNewText("");
      setStatus(null);
    } catch (err: any) {
      setStatus(null);
      setErrorMsg(err?.message ?? "Failed to save note");
    }
  }

  async function handleDelete(id: string) {
    setStatus("Deleting...");
    setErrorMsg(null);
    try {
      await deleteNote(id);
      setStatus(null);
    } catch (err: any) {
      setStatus(null);
      setErrorMsg(err?.message ?? "Failed to delete note");
    }
  }

  if (!user) {
    return (
      <div style={{ padding: 20, maxWidth: 640 }}>
        <h1>Cloud Notes</h1>
        <p>Sign in with Google to create and view your notes.</p>
        <button onClick={handleSignIn}>Sign in with Google</button>
        {status && <div style={{ marginTop: 12 }}><em>{status}</em></div>}
        {errorMsg && <div style={{ marginTop: 12, color: "crimson" }}>{errorMsg}</div>}
      </div>
    );
  }

  return (
    <div style={{ padding: 20, maxWidth: 900 }}>
      <header style={{ display: "flex", gap: 12, alignItems: "center" }}>
        <h1 style={{ margin: 0 }}>Cloud Notes</h1>
        <div style={{ marginLeft: "auto", textAlign: "right" }}>
          <div><strong>{user.displayName ?? user.email ?? "Signed in"}</strong></div>
          <div style={{ fontSize: 12, color: "#555" }}>{user.email}</div>
          <div style={{ marginTop: 8 }}>
            <button onClick={handleSignOut}>Sign out</button>
          </div>
        </div>
      </header>

      <section style={{ marginTop: 16 }}>
        <h3>Notes</h3>

        <div style={{ marginBottom: 12 }}>
          <label style={{ fontSize: 13 }}>
            <input
              type="checkbox"
              checked={showAll}
              onChange={(e) => setShowAll(e.target.checked)}
            />{" "}
            Demo: subscribe to <strong>all</strong> notes (insecure until rules)
          </label>
        </div>

        <div style={{ display: "flex", gap: 8, marginBottom: 12 }}>
          <input
            style={{ flex: 1, padding: "8px 10px" }}
            placeholder="Write a note..."
            value={newText}
            onChange={(e) => setNewText(e.target.value)}
            onKeyDown={(e) => { if (e.key === "Enter") handleAddNote(); }}
          />
          <button onClick={handleAddNote}>Add</button>
        </div>

        {status && <div style={{ marginBottom: 10 }}><em>{status}</em></div>}
        {errorMsg && <div style={{ marginBottom: 10, color: "crimson" }}>{errorMsg}</div>}

        {notes.length === 0 ? (
          <div style={{ color: "#666" }}>You have no notes yet.</div>
        ) : (
          <ul style={{ paddingLeft: 18 }}>
            {notes.map((n) => (
              <li key={n.id} style={{ display: "flex", gap: 10, marginBottom: 8, alignItems: "center" }}>
                <div style={{ flex: 1 }}>{n.text}</div>
                <button onClick={() => handleDelete(n.id)}>Delete</button>
              </li>
            ))}
          </ul>
        )}

        <div style={{ marginTop: 18, fontSize: 13, color: "#555" }}>
          <strong>Debug:</strong> uid = {user.uid}
        </div>
      </section>
    </div>
  );
}
```

---

## Part D — Run locally and verify

## Step 10 — Start the dev server

::: {.callout-note collapse="false"}
## devserver.exe

```bash
npm run dev
```

Open the URL shown (usually `http://localhost:5173`).

- Click **Sign in with Google**
- Add 2–3 notes
- Confirm notes persist across refresh
:::

::: {.callout-warning collapse="true"}
## missing-index.txt — If you see “query requires an index”

If you get an error like:

> `failed-precondition: The query requires an index`

Click the link in your browser console to create the Firestore index, then wait until it is “Ready”.

This commonly happens when using both:
- `where("uid" == ...)` and
- `orderBy("createdAt")`
:::

---

## Part E — In-class activity: the insecure query

::: {.callout-important collapse="false"}
## activity.exe — Try reading other people’s notes (in a controlled way)

1. Pair up with a classmate.
2. Each of you opens **your own** app in the browser and signs in.
3. Each person adds 2–3 notes.
4. Now, in your app, toggle:

**“Demo: subscribe to all notes”**

If your Firestore rules are still in **test mode**, you will likely be able to see notes from other users.

That is the problem we will fix next.
:::

---

## Part F — Fix it: Firestore Security Rules (Authorization)

## Step 11 — Add Firestore rules

::: {.callout-note collapse="false"}
## rules.exe — Server-side policy

Firebase Console → Firestore Database → **Rules**

Replace the test-mode rules with:

```js
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    match /notes/{noteId} {
      // Create: must be signed in and must set uid to your uid
      allow create: if request.auth != null
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.text is string;

      // Read/update/delete: only if the document belongs to you
      allow read, update, delete: if request.auth != null
                                  && resource.data.uid == request.auth.uid;
    }
  }
}
```

Click **Publish**.
:::

## Step 12 — Verify the fix

::: {.callout-tip collapse="false"}
## verify.exe

Return to your app:

- Toggle **Demo: subscribe to all notes**
- You should now see a **permission** error (or only your permitted documents)
- Toggle back to “my notes” and confirm your notes still load

This proves that **authorization lives at the database boundary**, not in the UI.
:::

---

## Part G — Deploy (same workflow as Lab 1)

## Step 13 — Deploy your updated app

::: {.callout-note collapse="false"}
## deploy.exe

Build and deploy:

```bash
npm run build
firebase deploy
```

Open the printed URL (ends with `.web.app`).
:::

---

## Submission

::: {.callout-important collapse="false"}
## submit.txt — What to turn in

Submit:

1. Your Firebase Hosting URL
2. A short response (3–6 sentences) answering:
   - What is the difference between **authentication** and **authorization**?
   - Why did the “show all notes” query work before rules but fail after rules?
   - Where is security enforced in this architecture?
:::

---

## Troubleshooting

::: {.callout-warning collapse="true"}
## errorlog.txt

**Sign-in button does nothing**  
- Ensure Google provider is enabled in Firebase Auth
- Check browser popup settings

**Env vars seem ignored**  
- Restart `npm run dev` after editing `.env.local`
- Confirm variables begin with `VITE_`

**Permission denied after adding rules**  
- Confirm notes include `uid` field
- Confirm rules match `uid == request.auth.uid`

**Index required**  
- Click the console link in the Firestore error to create the composite index
:::
