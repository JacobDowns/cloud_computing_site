---
title: "Lecture 5 — Git"
---

::: {.callout-note collapse="false"}
## agenda.txt — Today’s plan

Today we move from "saving files" to "managing history," and then we teach robots to do the heavy lifting for us.

1.  **The Essentials**: Commits, Staging, and Remotes (Refresher)
2.  **Git vs. GitHub**: The Tool vs. The Service
3.  **Time Travel Mechanics**: HEAD, Relative Offsets, Checkout, Reset, Revert, and Detached States
4.  **The Multiverse**: Merge vs. Rebase
:::

## Why this lecture exists

::: {.callout-important collapse="false"}
## version_control.nfo — Stop naming files "final_v2_REAL.zip"

While git is very powerful, we often learn it in a haphazard way. This lecture attempts to present git as a tool for managing timelines instead of saving files.
:::

::: {.callout-note collapse="false"}
## timelines.jpg

![Movie timelines. ](images/timelines.jpg){fig-align="center"}
:::

------------------------------------------------------------------------

## Part 1: The Essentials (Refresher)

While you're probably familar with these concepts, its worth refreshing some Git basics.

::: {.callout-note collapse="false"}
## save_game.sav — What is a Commit?

-   A **Commit** is not just "saving a file." It is a snapshot of your **entire project folder** at a specific moment in time.
-   Think of it like a **Save Point** in a video game.
-   If you die (break your code), you respawn at the last Commit.

**The Three-Step Workflow:**

1.  **Working Directory:** You edit some files
2.  **Staging Area (`git add`):** You put specific files into the staging area
3.  **Commit (`git commit`):** You commit whatever is in the staging area, creating a snapshot for posterity
:::

::: {.callout-tip collapse="false"}
## history.log — Seeing the Past

How do you see the timeline of commits?

``` bash
git log
```

Better yet, use the "pretty" version to see branches:

``` bash
git log --oneline --graph --all
```

**Structure of a Log Entry:**

-   **Hash (`a1b2c3d`):** The unique ID of the commit.
-   **Author:** Who did it.
-   **Date:** When they did it.
-   **Message:** "Fixed the login bug" (Please write good messages, unlike me).
:::

::: {.callout-warning collapse="false"}
## exclude.txt — The .gitignore File

Often, there are files you never want to commit:

1.  **Dependencies:** `node_modules/` (It's huge; 500MB+).
2.  **Secrets:** `.env` (API Keys, Passwords).
3.  **Build Artifacts:** `dist/` or `build/` (The generated files).

**The Solution:** Create a file named `.gitignore` and list the folders there. Git will become blind to them.
:::

::: {.callout-note collapse="false"}
## network.net — Remotes and Origins

Your code lives on your laptop. A **Remote** is a copy of your code living somewhere else (like GitHub).

-   **`origin`:** This is just a nickname. Instead of typing `https://github.com/me/my-repo.git` every time, Git lets us call it `origin`.

**Connecting to the Cloud:** If you have a local repo and want to attach it to a new GitHub repo:

``` bash
# 1. Add the "phone number" of the remote server
git remote add origin [https://github.com/user/repo.git](https://github.com/user/repo.git)

# 2. Push your main branch to the origin
git push -u origin main
```
:::

::: {.callout-note collapse="false"}
## branches.tree — Alternate Realities

By default, Git is a straight line (`main`). But what if you want to experiment without breaking the working code? You create a **Branch**.

**The Sci-Fi Analogy:**

-   **`main`:** The "Sacred Timeline." This code works. It is the truth.
-   **`feature-x`:** A divergent timeline. You can mess up here, delete files, or crash the app. It does not affect the Sacred Timeline.

**Core Commands:**

``` bash
# 1. Create a new dimension (Branch)
git branch feature-login

# 2. Travel to that dimension
git checkout feature-login

# Shortcut: Do both at once
git checkout -b feature-login
```

![Diverging timelines.](images/future.jpg){fig-align="center"}

### Visualizing Branches

> [A highly recommended and fun tool for learning git branching](https://learngitbranching.js.org/)
:::

------------------------------------------------------------------------

## Part 2: The Tool vs. The Platform

::: {.callout-tip collapse="false"}
## distinction.txt — Git is not GitHub

A common confusion is treating **Git** and **GitHub** as the same thing. They are not.

| Feature | **Git** | **GitHub / GitLab / Bitbucket** |
|:-----------------------|:-----------------------|:-----------------------|
| **Role** | The Engine (Software) | The Garage (Hosting Service) |
| **Location** | Runs locally on your laptop. | Runs on a server in the cloud. |
| **Analogy** | Like **Microsoft Word**. You use it to write the document on your PC. | Like **Google Drive**. You upload your document there to share and backup. |
| **Dependencies** | Works 100% offline. | Requires internet. |
| **Key Features** | Commits, Branches, Merges. | Pull Requests, Issues, Actions, CI/CD. |

*You can use Git without GitHub. You cannot use GitHub without Git.*
:::

### Pull Requests

::: {.callout-tip collapse="false"}
## pr_check.exe — Not a Git Feature

A **pull request** (PR) is a formal request for project maintainers to pull your changes from your feature branch into the target branch (commonly the `main` branch.

-   Technically, a pull request is is not actually a git command. It is a feature invented by platforms like GitHub.

**Terminology:**

-   **GitHub / Bitbucket:** "Pull Request" (PR).
-   **GitLab:** "Merge Request" (MR).

> **The Concept:** Git allows you to merge code whenever you want. This can be dangerous in a team. A **PR** is a wrapper around a merge that forces a conversation.

**The Workflow:**

1.  **You:** Push `feature-login` branch to GitHub.
2.  **You:** Click "Create Pull Request." (Essentially saying: *"I think I'm done. Please review this."*)
3.  **Team:** Reads your code, leaves comments ("Fix this line"), and approves it.
4.  **GitHub:** Only allows the **Merge Button** to be clicked after approval (and after CI/CD passes!).
:::

::: {.callout-important collapse="false"}
## access_denied.err — The Locked Door

In a professional setting, if you try to run: `git push origin main`

You will see this error: `remote: error: GH006: Protected branch update failed for refs/heads/main.`

**Why?**

Teams use **Branch Protection Rules** to physically lock the `main` branch.

-   **Rule 1:** "Require a Pull Request before merging."
-   **Rule 2:** "Require status checks to pass" (CI/CD must be green).
-   **Rule 3:** "Require 1 approving review" (Another human must say yes).

This prevents "Cowboy Coding" where someone pushes broken code directly to production without the rest of the team signing off on it.
:::

------------------------------------------------------------------------

## Part 3: Time Travel Mechanics

::: {.callout-note collapse="false"}
## head_pointer.dll — You Are Here

In Git, **HEAD** is a pointer or reference to the current commit on the current branch. Usually, HEAD points to a **branch** (like `main`), and the branch points to the latest **commit**.

### **Relative Offsets (Math with Time)**

Sometimes you want to reference "The commit before this one." We use math for that:

-   `HEAD`: Where I am right now.
-   `HEAD~1`: The parent of this commit (1 step back).
-   `HEAD~2`: The grandparent (2 steps back).
-   `HEAD~5`: 5 commits ago.

**Example Use Case:** "I want to undo the last 3 commits." `git reset --hard HEAD~3`
:::

::: {.callout-warning collapse="false"}
## detached_head.err — Floating in Space

If you run `git checkout <commit-hash>` (jumping to a specific point in history instead of a branch name), you enter **Detached HEAD state**.

**What this means:**

-   You are looking at a snapshot of the past.
-   **Danger:** If you make new commits here, **they belong to no branch.**
-   If you switch back to `main` without creating a new branch, your new commits will be lost in the void (garbage collected).

**How to fix it:** If you made cool changes while detached, run: `git checkout -b new-feature-branch.` This creates a timeline (branch) to save your work.
:::

### The Time Cop Protocol (Undo Strategies)

::: {.callout-note collapse="false"}
## paradox_prevention.doc — Choosing your Weapon

When you make a mistake, you have three ways to manipulate the space-time continuum. The difference isn't just "how" they work, but **what happens to the timeline**.
:::

![](images/timecop.jpg){fig-align="center" width="571"}

### 1. `git checkout`

> **"I just want to see what the code looked like last Tuesday."**

-   **The Idea:** You travel back to a specific moment in history. You can look around, run the code, and examine files. However, you are just a "Ghost."
-   **The Rules:** You are **not** changing the timeline. You are just moving your camera to a previous frame.
-   **Safety:** **100% Safe.**

### 2. `git revert`

> **"I pushed a bug to production and need to fix it ASAP."**

-   **The Idea:** You cannot stop the explosion (Bug) that happened yesterday. It is a fixed point in time; it is already in the history books. However, you can create a **new event** today that perfectly reconstructs the building.
-   **The Result:** The timeline grows longer.
    -   Event A: "Villain destroys City" (The Bug).
    -   Event B: "Hero rebuilds City" (The Revert).
-   **Safety:** You are basically trying to change a singular event (commit) in the past but otherwise keep the timeline intact. This has potential side effects but it erases no history. 

### 3. `git reset`

> **"I messed up locally and want to pretend it never happened."**

-   **The Idea:** You travel back to yesterday morning and stop yourself from ever writing that bad code. Everything that happened between then and now is **erased**. It ceases to exist.
-   **The Result:** The timeline gets shorter. The events are gone.
-   **Safety:** **DANGEROUS.**
    -   If you prune a timeline that your teammates are currently living in (a Public Branch), you create a **Paradox** (Merge Conflicts).
    -   **Rule:** Only prune your own private timelines.

### Summary Table

| Command    | Concept             | Changes History?      | Safe for Public Repos? |
|:----------------|:----------------|:------------------|:-------------------|
| `checkout` | **Observation**     | No                    | ✅ Yes                 |
| `revert`   | **Counter-Measure** | No (Adds to it)       | ✅ Yes                 |
| `reset`    | **Erasure**         | **Yes (Destructive)** | ❌ **NO**              |

------------------------------------------------------------------------

### The Mechanics of Reset (Soft vs. Hard)

::: {.callout-important collapse="false"}
## git_internals.dll — The Three Trees

To understand reset, it helpf to visualize where your code lives.

1.  **HEAD (The Repository):** The saved history.
2.  **Index (Staging):** The "Draft" you are about to commit.
3.  **Work Dir (Your Disk):** The raw files you are editing.
:::

### Scenario: The "Bad Commit"

You just ran `git commit`, but you realized you forgot to include a file, or you put your API key in the code. You want to undo that commit (`Commit B`) and go back to `Commit A`.

### Option 1: `git reset --soft HEAD~1`

**"Move the History, Keep the Progress."**

-   **HEAD:** Moves back to `Commit A`.
-   **Index (Staging):** Stays the same. The changes from `Commit B` are left sitting in the Staging Area ("Green" in `git status`).
-   **Work Dir:** **STAYS THE SAME.** Your files are untouched.
-   **The Result:** It looks exactly like you just ran `git add` but haven't run `git commit` yet.
-   **Technical Use:** "I want to add or remove files from the commit or fix the commit message. I don't want to lose my code."

### Option 2: `git reset --hard HEAD~1`

**"Scorched Earth."**

-   **HEAD:** Moves back to `Commit A`.
-   **Index (Staging):** **RESET.** It is forced to match `Commit A`.
-   **Work Dir:** **RESET.** It is forced to match `Commit A`.
-   **The Result:** The changes from `Commit B` are **deleted from your disk.** They are gone.
-   **Technical Use:** "I completely broke everything. Please destroy all my recent work and reset my computer to how it looked yesterday."

::: {.callout-tip collapse="false"}
## comparison.tbl — The Cheat Sheet

| Command                       | HEAD moves? | Staging Index? | Working Files? |
|:------------------------------|:------------|:---------------|:---------------|
| `git reset --soft`            | ✅ Yes      | Kept           | Kept           |
| `git reset --mixed` (Default) | ✅ Yes      | Unstaged       | Kept           |
| `git reset --hard`            | ✅ Yes      | **Destroyed**  | **Destroyed**  |
:::

## Part 4: Merge vs. Rebase

::: {.callout-note collapse="false"}
## integration.exe — Combining Timelines

Let's say you were working on a new login feature on the `feature-login` branch. You're finished, so how to you incorporate this work into `main`?

### **Option A: Merge (`git merge`)**

Integrates changes by creating a new commit (the merge commit) that ties two branch histories together.

-   **Pros:** Preserves the exact history, shows when branches diverged and merged, safer for shared branches.
-   **Cons:** Creates extra merge commits, leading to a "messy" or cluttered history, especially with frequent merges.
-   **When to use:** When bringing a finished feature into a shared branch like `main`.

### **Option B: Rebase (`git rebase`)**

Moves your feature branch's base to the tip of the target branch (e.g., main), reapplying your commits one by one as if they were made later.

-   **Pros:** Creates a clean, linear project history (no merge commits), easier to read and navigate with `git log`.
-   **Cons:** Rewrites history (new commit IDs), which can cause major issues if done on shared branches; conflicts may need resolving multiple times (once per commit).
-   **When to use:** To update your local feature branch with the latest changes from main to keep your work current and clean before you create a pull request.

![Merge v. Rebase](images/merge.png){fig-align="center"}
:::

::: {.callout-warning collapse="false"}
## rebase.txt — The Golden Rule of Rebase

Don't rebase a public branch. If other people are working on your branch, and you rebase it, you break their history. Only rebase code that exists solely on your machine.
:::