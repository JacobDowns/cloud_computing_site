---
title: "Lecture 3 — Web & Network Fundamentals for the Cloud"
---

::: {.callout-note collapse="false"}
## agenda.txt — Today’s plan

Today we’ll focus on the **web and networking fundamentals** that help explain what actually happens when you deploy an app to the cloud.

1.  **The Request Model**: Client → Server
2.  **The Internet Postal Service**: A unified model for:
    -   **HTTP** (The Message)
    -   **DNS** (The Address)
    -   **TCP/IP** (The Logistics)
    -   **HTTPS** (The Lockbox)
3.  **Statelessness**: Why the web forgets you
4.  **Load Balancers**: The "Invisible Infrastructure"
5.  **Reference**: Common Codes & Methods
:::

## Why this lecture exists
In Lab 1, you deployed a real web app and got a public URL. This lecture answers the question:

::: {.callout-important collapse="false"}
**What actually happens between a browser and a cloud-hosted application?**
:::

------------------------------------------------------------------------

## 1. The Request Model

At a high level, the web works on a **Request–Response** cycle.

-   **Client:** Initiates the conversation ("I want this file").
-   **Server:** Processes the order and sends back a response ("Here is your file").

::: {.callout-note collapse="false"}
## diagram.png — The Cycle

![The client and server.](images/simple-client-server.png){fig-align="center"}
:::

------------------------------------------------------------------------

## 2. The Internet Postal Service

To understand how the cloud works, we'll use the analogy of sending a letter. In this analogy:

1\. **HTTP** is the letter inside the envelope (the content).

2\. **DNS** is the phonebook we use to find the destination address.

3\. **TCP/IP** is the postal system (trucks, sorting centers) that moves the letter.

4\. **HTTPS** is the security envelope that prevents the mailman from reading your letter.

### Part A: HTTP (The Letter)

::: {.callout-note collapse="false"}
## protocol.ini — The Language

**HTTP (HyperText Transfer Protocol)** is the rulebook for what we write *inside* the letter.

When your browser wants a webpage, it essentially writes a note to the server:

> **To:** Google Server **Message:** GET /index.html **From:** Chrome Browser

The server reads this note, finds the file, and writes a return letter:

> **Status:** 200 OK (I found it!) **Content:** `<html>...</html>`

-   If we didn't have HTTP, the server wouldn't know how to read your request.
-   That is, this is a language that allows communication between client and server.
:::

### Part B: DNS (The Address Book)

::: {.callout-note collapse="false"}
## dns_lookup.exe — Names vs. Numbers

You wrote your letter to "Google.com". But the postal system (the Internet) doesn't know where "Google.com" is. It only understands numeric coordinates (IP Addresses), like `142.250.190.46`.

Before sending the letter, your computer consults the **DNS (Domain Name System)**.

1.  **You:** "I have a letter for `google.com`. What is their number?"
2.  **DNS Server:** "One moment... `google.com` is located at `142.250.190.46`."
3.  **You:** *Writes `142.250.190.46` on the envelope.*

-   **Cloud Context:** When you deploy to Firebase, you get a name (`web.app`). Behind the scenes, Google updates the DNS "phonebook" to point that name to their load balancers.
-   For more detail see this [article](https://www.cloudflare.com/learning/dns/what-is-dns/) on CloudFlare
:::

### Part C: Ports (The Suite Number)

- Your server is a large building that runs many different programs at once (a Web Server, a Database, an Email Server).
- If a packet arrives at `142.250.190.46`, how does the OS know which program should receive it?

It uses a **Port Number**.

* **IP Address:** Gets you to the correct computer (The Building).
* **Port Number:** Gets you to the correct **application** running on that computer (The Suite #).


::: {.callout-tip collapse="false"}
## well_known_ports.txt — The Standard Doors

| Port | Service | Description |
| :--- | :--- | :--- |
| **80** | **HTTP** | Unencrypted Web Traffic (Default for `http://`). |
| **443** | **HTTPS** | Secure Web Traffic (Default for `https://`). |
| **22** | **SSH** | Secure Shell (Remote Control). |
| **53** | **DNS** | The phonebook service itself. |
| **5432** | **Postgres** | Default for PostgreSQL databases. |
:::

### Part D: TCP/IP (The Logistics)

Now that the letter is written (HTTP) and addressed (DNS), it needs to be shipped. This is **TCP/IP**.

**IP (Internet Protocol) = The Address Label**

-   IP is responsible for routing.
-   It looks at the destination (`142.250.190.46`) and figures out which road (router) the truck should take to get closer to the destination.

**TCP (Transmission Control Protocol) = The Certified Mail Service**

-   The internet is chaotic. Roads close; trucks get lost.
-   TCP ensures reliability by chopping your letter into numbered pieces (packets): \* "Packet 1 of 3" \* "Packet 2 of 3" \* "Packet 3 of 3"
-   If "Packet 2" falls off the truck, TCP notices it's missing and calls the sender: *"Hey, I got 1 and 3, but 2 is missing. Resend it!"*

::: {.callout-warning collapse="false"}
## udp.dll — The Alternative: Speed over Reliability

While **TCP** is like "Certified Mail" (careful, tracked, guaranteed), **UDP (User Datagram Protocol)** is the **"Fire and Forget"** mode.

-   **Analogy:** Throwing newspapers from a moving truck.

    -   The driver throws them out as fast as possible.
    -   If one lands in a puddle or hits a bush? Too bad. The truck doesn't stop to fix it.

    ![](images/tcp.png)

**Why use an unreliable protocol?**

-   **Real-time Video (Zoom/Netflix):** If a video packet gets lost, it's better to have a tiny "glitch" on screen than to **freeze** the video while waiting for a resend (buffering).
-   **Gaming:** You need the *current* player position immediately. You don't care where they were 2 seconds ago.
:::

### Part E: HTTPS (The Security)


Standard HTTP is like a **Postcard**. Anyone who touches it—the mailman, the sorting facility, the truck driver—can read it.

**HTTPS** wraps your letter in a **Locked Briefcase**.

1.  **Encryption:** You lock the message. Only the destination server has the key.
2.  **Identity:** The briefcase has a verified seal (SSL Certificate) proving it really goes to Google, not an imposter.

This is the standard for the cloud.


## Simple Demo

::: {.callout-tip collapse="false"}
## telnet.exe 

We can show that HTTP is just plain text by sending a request *without* a browser.

**Step 1: Open your Terminal**
* **Windows:** Press `Win + R`, type `cmd`, hit Enter.
* **Mac/Linux:** Open your "Terminal" app.

**Step 2: Open a Connection (The TCP Handshake)**
Run this command to connect to Google on Port 80. This creates the "pipe" between your computer and theirs.
*(Note: If `telnet` isn't installed, use `nc` or `ncat`)*

```bash
telnet google.com 80
# OR
nc google.com 80
```

**Step 3: Write the Letter (The HTTP Request)**
Once the screen goes blank or says "Connected", type the following exactly.
*Note: The server is very picky about typos!*

```http
GET / HTTP/1.1
Host: www.google.com

```
*(You MUST hit **Enter twice** at the end to send the request)*

**Step 4: Analyze the Result**
You will see a flood of text. This is the **Response**.

* Look for `HTTP/1.1 200 OK` (The Status Code).
* Look for `Set-Cookie` (The Server trying to give you a wristband).
* Look for `<!doctype html>` (The actual HTML content).
:::

::: {.callout-note collapse="false"}
## traceroute.bat — Visualize the Path

Want to see the actual "Roads" and "Intersections" your data travels through?

**Run this command:**

```bash
# Windows Users
tracert google.com

# Mac / Linux Users
traceroute google.com
```

**What you are seeing:**

* **Row 1:** Your local router (WiFi gateway).
* **Rows 2-4:** Your ISP (Comcast, Verizon, University Network).
* **Middle Rows:** Major internet backbones (undersea cables, fiber lines).
* **Final Row:** The Google Data Center that answered you.

*Tip: If you see `* * *`, that just means a router is configured to be "secret" and ignore trace requests. This is what happened to me when I tried it. Very sad.*
:::

------------------------------------------------------------------------

## 3. Deep Dive: Statelessness

When we say HTTP is **stateless**, we mean the server treats every single request as a completely new interaction.

**The Scenario:** 1. You log in (`POST /login`). The server checks your password and says "Success." 2. One second later, you ask for your profile (`GET /profile`).

**The Problem:** In a stateless world, the server does **not** remember that *you* were the one who just logged in. It has already forgotten you. It asks, "Who are you?"

**The Solution:** You must provide proof of identity (a Token/Cookie) with **every single request**, forever.

::: {.callout-tip collapse="false"}
## cookies.jpeg

![](images/cookies-2.jpg){fig-align="center" width="451"}
:::

::: {.callout-tip collapse="false"}
## analogy.log — The Call Center

To understand **why** we do this, imagine a Customer Support Call Center.

**Option A: Stateful**

-   You call and get Agent Steve.
-   Steve writes your details on a sticky note on his desk.
-   **The Constraint:** If you hang up and call back, you **must** get Steve again. No one else has your sticky note.
-   **The Risk:** If Steve goes to lunch (or his phone breaks), your session is gone. You have to start over.

**Option B: Stateless**

-   You call and get Agent Steve.
-   Steve types your details into a central database (not a sticky note).
-   **The Benefit:** If you hang up and call back, you can talk to Agent Sarah, Agent Mike, or Agent Linda.
-   They just look up your ID in the central database and pick up exactly where Steve left off.

**Cloud Translation:**

-   **Agents** = Web Servers (running your code).
-   **Sticky Note** = Server Memory (RAM).
-   **Central Database** = Cloud Database (Firestore, SQL, Redis).
:::

::: {.callout-important collapse="false"}
## callcenter.png — The Call Center Analogy

![](images/call.jpeg){fig-align="center"}
:::

::: {.callout-important collapse="false"}
## scaling.exe — Servers are Ephemeral

Stateless requests and server architecture allows us to treat servers as ephemeral. This has some major advantages:

-   Servers can easily be swapped out.
-   It doesn't matter which server answers your request
-   You can delete serve A, replace it with server B, or add 100 new servers quickly without the user noticing.
-   This leads to massive horizontal scalability.

Because "Server-045" held no unique data (statelessness), its death caused **zero data loss** for the users. This is one way the cloud achieves 99.99% reliability.
:::

::: {.callout-warning collapse="false"}
## persistence.cfg — So where does the data go?

If the server doesn't hold the data, where does it live?

1.  **The Client (Browser):** Holds the "Session ID" or "Auth Token" (the wristband that proves who you are).
2.  **The Database:** Holds the actual heavy data (profiles, cart items, chat logs).

**Takaways:**

-   **Compute is temporary:** It can disappear at any time.
-   **State (Data) is external:** It lives in a dedicated database layer, safe from server crashes.
:::

------------------------------------------------------------------------

## 4. Load Balancers

A Load Balancer is essentially a **Reverse Proxy**.

-   **Forward Proxy:** You use it to hide your identity *from* the internet (like a VPN).
-   **Reverse Proxy:** The internet talks to it, and it hides the identity of your servers *from* the internet.
-   When a user visits `google.com`, they are hitting a Load Balancer.
-   That machine doesn't have the data. It acts as a middleman, turning around and asking one of thousands of backend servers for the answer, then passing it back to you.

::: {.callout-tip collapse="false"}
## algorithm.cfg — How does it choose?

How does the Load Balancer decide which server gets your request? It follows a set of rules (Algorithms):

1.  **Round Robin (The "Take Turns" Method):**
    -   Request 1 → Server A
    -   Request 2 → Server B
    -   Request 3 → Server C
    -   Request 4 → Server A (Loop back to start)
    -   *Pros:* Simple. *Cons:* Doesn't care if Server A is struggling with a huge task while Server B is idle.
2.  **Least Connections (The "Shortest Line" Method):**
    -   The Load Balancer looks at who is busy.
    -   "Server A has 50 active users. Server B has 2."
    -   **Action:** Send next user to Server B.
    -   *Pros:* Smarter distribution. Prevents one server from getting swamped.
:::

::: {.callout-important collapse="false"}
## balance.webp — Achieving Balance

![](images/balance-2.webp){fig-align="center"}

![Demonstration of load balancing from: <https://www.cloudflare.com/learning/performance/what-is-load-balancing/>](images/balance1.webp){fig-align="center"}
:::

::: {.callout-important collapse="false"}
## health_check.log — The Heartbeat

This is the most critical feature for reliability. Every few seconds, the Load Balancer pings every server with a tiny question: *"Are you alive?"* (usually `GET /health`).

-   **Server A:** "200 OK" (I'm good).
-   **Server B:** "200 OK" (I'm good).
-   **Server C:** *...Silence...* (or 500 Error).

**The Action:** The Load Balancer immediately **removes Server C from the rotation.**

-   Users are never sent to Server C, so they never see an error page.
-   When Server C reboots and replies "200 OK" again, it gets re-added to the rotation automatically.
:::

::: {.callout-warning collapse="false"}
## ssl_offload.dll — specialized tasks

In practice, Load Balancers also do **SSL Termination**.

- Decrypting HTTPS traffic ("unlocking the briefcase") takes a lot of CPU power. 
- Instead of making your web servers do this math, the **Load Balancer** unlocks the briefcase, inspects the request, and passes the *unencrypted* request to your web servers over a private, fast network.
- This lets your web servers focus 100% on running your application code, not solving cryptography math.
:::

------------------------------------------------------------------------

## 5. Appendix: HTTP Cheat Sheet

::: {.callout-note collapse="false"}
## methods.txt — The Verbs

These are the instructions you write on the "Letter" (HTTP Request) so the server knows what you want to do.

| Verb       | Usage                 | Analogy                                  |
|:-----------------------|:-----------------------|:-----------------------|
| **GET**    | Retrieve data.        | "Please send me a copy of the menu."     |
| **POST**   | Submit new data.      | "Here is my completed application form." |
| **PUT**    | Update existing data. | "Here is a correction to my address."    |
| **DELETE** | Remove data.          | "Please shred my file."                  |
:::

::: {.callout-warning collapse="false"}
## status_codes.log — The Responses

The 3-digit number the server writes on the return envelope.

| Code | Series | Meaning | Postal Analogy |
| :--- | :--- | :--- | :--- |
| **200** | **OK** | Request Succeeded. | "Here is the package you ordered." |
| **201** | **Created** | Resource Created. | "I have successfully filed your new application." |
| **301** | **Moved** | Permanent Redirect. | "We moved to a new building. Go to this address." |
| **400** | **Bad Req** | Client Error. | "Your handwriting is messy; I can't read this." |
| **401** | **Unauth** | No Identity. | "Who are you? (You forgot your wristband/token)." |
| **403** | **Forbidden** | No Permission. | "I know who you are, but you aren't allowed in here." |
| **404** | **Not Found** | Missing Resource. | "That file doesn't exist." (Return to sender). |
| **500** | **Error** | Server Crash. | "The kitchen is on fire. Try again later." |
| **503** | **Unavailable** | Server Busy/Down. | "We are closed for renovations (maintenance)." |
:::

## 6. Recap


1.  **HTTP** is the message content.
2.  **DNS** finds the destination coordinates.
3.  **TCP/IP** reliably ships the packets across the world.
4.  **HTTPS** locks the data so intermediaries can't read it.
5.  **Status Codes** are how the server tells you if the letter was delivered or if the kitchen is on fire.

## 7. Sources & Further Reading

::: {.callout-tip collapse="false"}
## Useful Resoruces

These are the industry-standard resources used by actual cloud engineers.

* **MDN Web Docs: HTTP Overview**
    [https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview)
    *The official handbook for how the web speaks. Read the "Components of HTTP-based systems" section.*

* **Cloudflare: How DNS Works**
    [https://www.cloudflare.com/learning/dns/what-is-dns/](https://www.cloudflare.com/learning/dns/what-is-dns/)
    *A step-by-step visual guide to the "Internet Phonebook," including the recursive lookup process.*

* **The Twelve-Factor App: Processes (Statelessness)**
    [https://12factor.net/processes](https://12factor.net/processes)
    *The "Bible" of modern cloud architecture. This specific chapter explains why "sticky sessions" are bad and why servers must be stateless.*
:::

::: {.callout-note collapse="false"}
## deep_dive.zip — Advanced Topics

For those who want to understand the "invisible" layers:

* **Cloudflare: What is Load Balancing?**
    [https://www.cloudflare.com/learning/performance/what-is-load-balancing/](https://www.cloudflare.com/learning/performance/what-is-load-balancing/)
    *Explains algorithms like "Round Robin" vs "Least Connection" and how health checks work.*

* **GeeksForGeeks: TCP/IP Model**
    [https://www.geeksforgeeks.org/computer-networks/tcp-ip-model/](https://www.geeksforgeeks.org/computer-networks/tcp-ip-model/)
    *A technical breakdown of the 4 layers (Link, Internet, Transport, Application).*

* **MDN: HTTP Status Codes**
    [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)
    *The complete list of every possible return code (200, 404, 500, 418, etc.).*
:::

::: {.callout-important collapse="false"}
## tools.exe — Try it yourself

Want to see this in action? Open your terminal:

* **Check DNS:** `dig google.com` (Mac/Linux) or `nslookup google.com` (Windows)
* **Trace the Route:** `traceroute google.com` (Mac/Linux) or `tracert google.com` (Windows)
* **See HTTP Headers:** Open Chrome DevTools (F12) $\rightarrow$ **Network** tab $\rightarrow$ Refresh page $\rightarrow$ Click any file.
:::
